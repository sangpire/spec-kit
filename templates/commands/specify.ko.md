---
description: 자연어 기능 설명으로부터 기능 명세서를 작성하거나 업데이트합니다.
handoffs: 
  - label: 기술 계획 수립
    agent: speckit.plan
    prompt: 명세서에 대한 계획을 작성합니다. 나는 다음으로 구축하고 있습니다...
  - label: 명세서 요구사항 명확화
    agent: speckit.clarify
    prompt: 명세서 요구사항 명확화
    send: true
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## 사용자 입력

```text
$ARGUMENTS
```

진행하기 전에 사용자 입력을 **반드시** 고려해야 합니다 (비어있지 않은 경우).

## 개요

트리거 메시지에서 `/speckit.specify` 다음에 사용자가 입력한 텍스트가 **바로** 기능 설명입니다. 아래에 `{ARGS}`가 그대로 표시되더라도 이 대화에서 항상 사용 가능하다고 가정하세요. 사용자가 빈 명령을 제공한 경우가 아니면 반복 요청하지 마세요.

해당 기능 설명이 주어지면 다음을 수행하세요:

1. **간결한 짧은 이름 생성** (2-4 단어):
   - 기능 설명을 분석하고 가장 의미있는 키워드 추출
   - 기능의 본질을 포착하는 2-4 단어 짧은 이름 생성
   - 가능하면 동작-명사 형식 사용 (예: "add-user-auth", "fix-payment-bug")
   - 기술 용어와 약어 보존 (OAuth2, API, JWT 등)
   - 간결하지만 한눈에 기능을 이해할 수 있을 만큼 설명적이어야 함
   - 예시:
     - "사용자 인증을 추가하고 싶습니다" → "user-auth"
     - "API용 OAuth2 통합 구현" → "oauth2-api-integration"
     - "분석용 대시보드 생성" → "analytics-dashboard"
     - "결제 처리 타임아웃 버그 수정" → "fix-payment-timeout"

2. **새 브랜치 생성 전에 기존 브랜치 확인**:

   a. 먼저, 최신 정보를 확보하기 위해 모든 원격 브랜치를 가져옵니다:

      ```bash
      git fetch --all --prune
      ```

   b. short-name에 대한 모든 소스에서 가장 높은 기능 번호 찾기:
      - 원격 브랜치: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 로컬 브랜치: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - 명세서 디렉토리: `specs/[0-9]+-<short-name>`와 일치하는 디렉토리 확인

   c. 다음 사용 가능한 번호 결정:
      - 세 소스 모두에서 모든 번호 추출
      - 가장 높은 번호 N 찾기
      - 새 브랜치 번호로 N+1 사용

   d. 계산된 번호와 short-name으로 스크립트 `{SCRIPT}` 실행:
      - 기능 설명과 함께 `--number N+1`과 `--short-name "your-short-name"` 전달
      - Bash 예시: `{SCRIPT} --json --number 5 --short-name "user-auth" "사용자 인증 추가"`
      - PowerShell 예시: `{SCRIPT} -Json -Number 5 -ShortName "user-auth" "사용자 인증 추가"`

   **중요**:
   - 가장 높은 번호를 찾기 위해 세 소스 모두 확인 (원격 브랜치, 로컬 브랜치, 명세서 디렉토리)
   - 정확한 short-name 패턴을 가진 브랜치/디렉토리만 일치
   - 이 short-name으로 기존 브랜치/디렉토리를 찾을 수 없으면 번호 1부터 시작
   - 기능당 이 스크립트를 한 번만 실행해야 함
   - JSON은 터미널에 출력으로 제공됨 - 실제 내용을 가져오려면 항상 참조
   - JSON 출력에는 BRANCH_NAME과 SPEC_FILE 경로가 포함됨
   - 'I'm Groot'와 같은 인수의 단일 따옴표는 이스케이프 구문 사용: 예: 'I'\''m Groot' (또는 가능하면 큰따옴표: "I'm Groot")

3. 필수 섹션을 이해하기 위해 `templates/spec-template.md` 로드.

4. 다음 실행 흐름을 따르세요:

    1. 입력에서 사용자 설명 파싱
       비어있으면: ERROR "기능 설명이 제공되지 않았습니다"
    2. 설명에서 핵심 개념 추출
       식별: 행위자, 동작, 데이터, 제약조건
    3. 불명확한 측면의 경우:
       - 컨텍스트와 업계 표준을 기반으로 정보에 입각한 추측 수행
       - 다음 경우에만 [확인 필요: 구체적인 질문]으로 표시:
         - 선택이 기능 범위나 사용자 경험에 중대한 영향을 미침
         - 다른 의미를 가진 여러 합리적인 해석이 존재
         - 합리적인 기본값이 존재하지 않음
       - **제한: 최대 3개의 [확인 필요] 마커**
       - 영향도에 따라 명확화 우선순위 지정: 범위 > 보안/개인정보 > 사용자 경험 > 기술 세부사항
    4. 사용자 시나리오 & 테스트 섹션 작성
       명확한 사용자 흐름이 없으면: ERROR "사용자 시나리오를 결정할 수 없습니다"
    5. 기능 요구사항 생성
       각 요구사항은 테스트 가능해야 함
       지정되지 않은 세부사항에 대해 합리적인 기본값 사용 (가정 섹션에 가정 문서화)
    6. 성공 기준 정의
       측정 가능하고 기술 중립적인 결과 생성
       정량적 지표(시간, 성능, 볼륨) 및 정성적 측정(사용자 만족도, 작업 완료) 모두 포함
       각 기준은 구현 세부사항 없이 검증 가능해야 함
    7. 주요 엔티티 식별 (데이터 관련시)
    8. 반환: SUCCESS (계획 준비 완료)

5. 템플릿 구조를 사용하여 SPEC_FILE에 명세서를 작성하고, 섹션 순서와 제목을 유지하면서 기능 설명(인수)에서 파생된 구체적인 세부사항으로 플레이스홀더를 교체합니다.

6. **명세서 품질 검증**: 초기 명세서를 작성한 후 품질 기준에 대해 검증:

   a. **명세서 품질 체크리스트 생성**: 다음 검증 항목이 포함된 체크리스트 템플릿 구조를 사용하여 `FEATURE_DIR/checklists/requirements.md`에 체크리스트 파일 생성:

      ```markdown
      # 명세서 품질 체크리스트: [기능명]
      
      **목적**: 계획 진행 전 명세서 완전성 및 품질 검증
      **작성일**: [DATE]
      **기능**: [spec.md 링크]
      
      ## 내용 품질
      
      - [ ] 구현 세부사항 없음 (언어, 프레임워크, API)
      - [ ] 사용자 가치와 비즈니스 요구에 집중
      - [ ] 비기술 이해관계자를 위해 작성됨
      - [ ] 모든 필수 섹션 완료
      
      ## 요구사항 완전성
      
      - [ ] [확인 필요] 마커가 남아있지 않음
      - [ ] 요구사항이 테스트 가능하고 명확함
      - [ ] 성공 기준이 측정 가능함
      - [ ] 성공 기준이 기술 중립적임 (구현 세부사항 없음)
      - [ ] 모든 수락 시나리오가 정의됨
      - [ ] 예외 상황이 식별됨
      - [ ] 범위가 명확하게 경계 지어짐
      - [ ] 의존성과 가정이 식별됨
      
      ## 기능 준비성
      
      - [ ] 모든 기능 요구사항에 명확한 수락 기준이 있음
      - [ ] 사용자 시나리오가 주요 흐름을 다룸
      - [ ] 기능이 성공 기준에 정의된 측정 가능한 결과를 충족
      - [ ] 명세서에 구현 세부사항이 누출되지 않음
      
      ## 참고사항
      
      - 불완전으로 표시된 항목은 `/speckit.clarify` 또는 `/speckit.plan` 전에 명세서 업데이트 필요
      ```

   b. **검증 확인 실행**: 각 체크리스트 항목에 대해 명세서 검토:
      - 각 항목에 대해 통과 또는 실패 여부 결정
      - 발견된 특정 문제 문서화 (관련 명세서 섹션 인용)

   c. **검증 결과 처리**:

      - **모든 항목 통과 시**: 체크리스트를 완료로 표시하고 6단계로 진행

      - **항목 실패 시 ([확인 필요] 제외)**:
        1. 실패한 항목과 특정 문제 나열
        2. 각 문제를 해결하기 위해 명세서 업데이트
        3. 모든 항목이 통과할 때까지 검증 재실행 (최대 3회 반복)
        4. 3회 반복 후에도 여전히 실패하면 체크리스트 참고사항에 남은 문제 문서화 및 사용자 경고

      - **[확인 필요] 마커가 남아있는 경우**:
        1. 명세서에서 모든 [확인 필요: ...] 마커 추출
        2. **제한 확인**: 3개 이상의 마커가 있으면 가장 중요한 3개만 유지 (범위/보안/UX 영향별) 하고 나머지는 정보에 입각한 추측 수행
        3. 필요한 각 확인(최대 3개)에 대해 다음 형식으로 사용자에게 옵션 제시:

           ```markdown
           ## 질문 [N]: [주제]
           
           **컨텍스트**: [관련 명세서 섹션 인용]
           
           **알아야 할 사항**: [확인 필요 마커의 구체적인 질문]
           
           **제안된 답변**:
           
           | 옵션 | 답변 | 영향 |
           |------|------|------|
           | A    | [첫 번째 제안 답변] | [이것이 기능에 미치는 의미] |
           | B    | [두 번째 제안 답변] | [이것이 기능에 미치는 의미] |
           | C    | [세 번째 제안 답변] | [이것이 기능에 미치는 의미] |
           | 사용자 정의 | 자신의 답변 제공 | [사용자 정의 입력을 제공하는 방법 설명] |
           
           **선택**: _[사용자 응답 대기]_
           ```

        4. **중요 - 테이블 포맷팅**: 마크다운 테이블이 올바르게 포맷되어 있는지 확인:
           - 파이프가 정렬된 일관된 간격 사용
           - 각 셀은 내용 주위에 공백이 있어야 함: `| 내용 |` not `|내용|`
           - 헤더 구분자는 최소 3개의 대시 필요: `|--------|`
           - 마크다운 미리보기에서 테이블이 올바르게 렌더링되는지 테스트
        5. 질문을 순차적으로 번호 지정 (Q1, Q2, Q3 - 최대 3개)
        6. 응답을 기다리기 전에 모든 질문을 함께 제시
        7. 사용자가 모든 질문에 대한 선택으로 응답하기를 기다림 (예: "Q1: A, Q2: 사용자 정의 - [세부사항], Q3: B")
        8. 사용자가 선택하거나 제공한 답변으로 각 [확인 필요] 마커를 교체하여 명세서 업데이트
        9. 모든 확인이 해결된 후 검증 재실행

   d. **체크리스트 업데이트**: 각 검증 반복 후 현재 통과/실패 상태로 체크리스트 파일 업데이트

7. 브랜치 이름, 명세서 파일 경로, 체크리스트 결과 및 다음 단계 준비 상태(`/speckit.clarify` 또는 `/speckit.plan`)와 함께 완료를 보고합니다.

**참고:** 스크립트는 작성 전에 새 브랜치를 생성 및 체크아웃하고 명세서 파일을 초기화합니다.

## 일반 가이드라인

## 빠른 가이드라인

- 사용자가 **무엇을** 필요로 하고 **왜** 필요한지에 집중.
- 구현 방법 회피 (기술 스택, API, 코드 구조 없음).
- 개발자가 아닌 비즈니스 이해관계자를 위해 작성됨.
- 명세서에 포함된 체크리스트를 생성하지 마세요. 별도 명령입니다.

### 섹션 요구사항

- **필수 섹션**: 모든 기능에 대해 완료되어야 함
- **선택적 섹션**: 기능과 관련이 있을 때만 포함
- 섹션이 적용되지 않으면 완전히 제거 ("해당 없음"으로 남기지 마세요)

### AI 생성의 경우

사용자 프롬프트로부터 이 명세서를 생성할 때:

1. **정보에 입각한 추측 수행**: 컨텍스트, 업계 표준 및 일반적인 패턴을 사용하여 공백 채우기
2. **가정 문서화**: 가정 섹션에 합리적인 기본값 기록
3. **명확화 제한**: 최대 3개의 [확인 필요] 마커 - 다음과 같은 중요한 결정에만 사용:
   - 기능 범위나 사용자 경험에 중대한 영향
   - 다른 의미를 가진 여러 합리적인 해석 존재
   - 합리적인 기본값 부재
4. **명확화 우선순위 지정**: 범위 > 보안/개인정보 > 사용자 경험 > 기술 세부사항
5. **테스터처럼 생각**: 모든 모호한 요구사항은 "테스트 가능하고 명확한" 체크리스트 항목에 실패해야 함
6. **확인이 필요한 일반적인 영역** (합리적인 기본값이 없는 경우에만):
   - 기능 범위 및 경계 (특정 사용 사례 포함/제외)
   - 사용자 유형 및 권한 (여러 충돌하는 해석이 가능한 경우)
   - 보안/규정 준수 요구사항 (법적/재정적으로 중요한 경우)

**합리적인 기본값의 예** (이것에 대해 묻지 마세요):

- 데이터 보존: 도메인에 대한 업계 표준 관행
- 성능 목표: 명시되지 않은 경우 표준 웹/모바일 앱 기대치
- 오류 처리: 적절한 대체 수단이 있는 사용자 친화적 메시지
- 인증 방법: 웹 앱의 경우 표준 세션 기반 또는 OAuth2
- 통합 패턴: 달리 명시되지 않은 경우 RESTful API

### 성공 기준 가이드라인

성공 기준은 다음과 같아야 합니다:

1. **측정 가능**: 특정 지표 포함 (시간, 백분율, 개수, 비율)
2. **기술 중립적**: 프레임워크, 언어, 데이터베이스 또는 도구에 대한 언급 없음
3. **사용자 중심**: 시스템 내부가 아닌 사용자/비즈니스 관점에서 결과 설명
4. **검증 가능**: 구현 세부사항을 알지 못해도 테스트/검증 가능

**좋은 예시**:

- "사용자가 3분 이내에 결제를 완료할 수 있음"
- "시스템이 10,000명의 동시 사용자 지원"
- "검색의 95%가 1초 이내에 결과 반환"
- "작업 완료율이 40% 향상"

**나쁜 예시** (구현 중심):

- "API 응답 시간이 200ms 미만" (너무 기술적, "사용자가 즉시 결과를 봄" 사용)
- "데이터베이스가 1000 TPS 처리 가능" (구현 세부사항, 사용자 대면 지표 사용)
- "React 컴포넌트가 효율적으로 렌더링" (프레임워크별)
- "Redis 캐시 히트율이 80% 이상" (기술별)
